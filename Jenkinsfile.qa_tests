// Jenkinsfile.qa_tests (in majd.kassem.business_qa.git)
pipeline {
    agent any // Use 'any' as it seems your existing setup on the agent works.

    parameters {
        string(name: 'STAGING_URL_PARAM', defaultValue: 'https://majd-kassem-business-dev.onrender.com/', description: 'URL of the SUT staging environment')
    }

    environment {
        QA_REPO = 'https://github.com/majd-j-kassem/majd.kassem.business_qa.git'
        QA_BRANCH = 'dev' // Or 'main' if your test code is kept on main
        LIVE_DEPLOY_JOB_NAME = 'SUT-Deploy-Live' // EXACT name of the Jenkins job for live deployment
        GIT_CREDENTIAL_ID = 'git_id' // <--- Use the ID you created in Step 1
    }

    stages {
        stage('Checkout QA Tests') {
            steps {
                script {
                    echo "Checking out QA repository: ${env.QA_REPO}, branch: ${env.QA_BRANCH}"
                    checkout scm
                }
            }
        }

        stage('Run QA Tests against Staging') {
            steps {
                script {
                    echo "Running Selenium tests against Staging URL: ${params.STAGING_URL_PARAM}"
                    // It's good practice to create the allure-results directory explicitly
                    // even if pytest can often create it.
                    sh "mkdir -p allure-results"
                    sh "mkdir -p test-results" // For JUnit XML if you decide to use it separately

    
                    sh "pytest src/tests --alluredir=allure-results --junitxml=test-results/junit_report.xml --browser chrome-headless --base-url ${params.STAGING_URL_PARAM}"
                }
            }
        }

        stage('Trigger SUT Live Deployment (if tests pass)') {
            when {
                // Only proceed if the current QA test build is SUCCESSFUL.
                expression { currentBuild.result == 'SUCCESS' }
            }
            steps {
                script {
                    echo "QA tests passed. Triggering live deployment job: ${env.LIVE_DEPLOY_JOB_NAME}"
                    build job: env.LIVE_DEPLOY_JOB_NAME, wait: true
                }
            }
        }
    }

    // --- Report Publishing and Cleanup ---
    post {
        always {
            script {
                echo 'Publishing Allure Test Report...'
                // This step tells Jenkins to find the raw Allure data in 'allure-results'
                // and build the interactive HTML report.
                allure([
                    reportDir: 'allure-results',
                    // Optional: If you configured a specific Allure CLI installation in Jenkins global tools config
                    // allureInstall: 'MyAllureCLI_2.x'
                ])

                echo 'Publishing JUnit XML Reports...'
                // Publish JUnit XML results for Jenkins' built-in Test Results view and trend graphs.
                junit 'test-results/junit_report.xml'

                // --- Optional: Update build description/display name for quick overview ---
                def testResultAction = currentBuild.testResultAction
                if (testResultAction != null) {
                    def totalTests = testResultAction.totalCount
                    def failedTests = testResultAction.failCount
                    def skippedTests = testResultAction.skipCount
                    currentBuild.displayName = "#${env.BUILD_NUMBER} (${totalTests} tests, ${failedTests} failed)"
                    currentBuild.description = "Total: ${totalTests} | Failed: ${failedTests} | Skipped: ${skippedTests}"
                }

                // Clean up the agent's workspace.
                // Make sure this is *after* all publishing steps, as they need the files.
                deleteDir()
            }
        }
        success {
            echo 'QA Tests pipeline finished successfully.'
        }
        failure {
            echo 'QA Tests pipeline FAILED. No deployment to live.'
            // You might want to explicitly set the build result to FAILURE if pytest itself didn't
            // and you want Jenkins to mark it as such even if the post-steps ran.
            // currentBuild.result = 'FAILURE'
        }
        unstable {
            echo 'QA Tests pipeline finished with unstable results (e.g., some tests failed).'
        }
    }
}